1、最优化决策，假设为了解决某一优化问题，需要依次作出n个决策D1，D2，…，Dn，如若这个决策序列是最优的，
对于任何一个整数k，1 < k < n，不论前面k个决策是怎样的，以后的最优决策只取决于由前面决策所确定的当前状态，
即以后的决策Dk+1，Dk+2，…，Dn也是最优的。

2、最优化原理必须满足以下条件：
    (1) 问题中的状态必须满足最优化原理；
    (2) 问题中的状态必须满足无后效性。
  所谓无后效性是指：下一时刻的状态只与当前状态有关，而和当前状态之前的状态无关，当前的状态是对以往决策的总结
  
3、动态规划的基础是最优化决策，一般称为DP问题，表现为求最大最小。解法为3点：
    问题的阶段
    每个阶段的状态
    从前一个阶段转化到后一个阶段之间的递推关系
  所以一般采用递归算法来解决，某个阶段某个状态下的最优值最短路径，最长公共子序列，最大价值
  
4、DP经典例题
    (1).Triangle
    Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.
    For example, given the following triangle
    [
         [2],
        [3,4],
       [6,5,7],
      [4,1,8,3]
    ]
    The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).
    Note:
    Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.  
    
    设状态为 f (i; j )，表示从从位置 (i; j ) 出发，路径的最小和，则状态转移方程为
    f(i,j)=min{f(i+1,j),f(i+1,j+1)}+(i,j)
    class Solution(object):
        def minimumTotal(self, triangle):
            """
            :type triangle: List[List[int]]
            :rtype: int
            """
            n = len(triangle)
            dp = triangle[n-1]
            for i in range(n-2,-1,-1): # 倒着写法，这个-1只是表示从n-2位置开始要循环的次数，n-2 - (-1)，循环次数为n-1次
                for j in range(i+1):
                    dp[j] = min( dp[j], dp[j+1] ) + triangle[i][j]
            return dp[0]


